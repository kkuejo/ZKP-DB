# ZKP検証の仕組み：proof.jsonとpublic_signals.jsonから何が検証されているか

## 目次

1. [概要：ZKP検証とは](#概要zkp検証とは)
2. [検証に必要な3つのファイル](#検証に必要な3つのファイル)
3. [public_signals.jsonの中身と意味](#public_signalsjsonの中身と意味)
4. [proof.jsonの中身と意味](#proofjsonの中身と意味)
5. [verification_key.jsonの役割](#verification_keyjsonの役割)
6. [検証の流れ：何が行われているか](#検証の流れ何が行われているか)
7. [実際の例で理解する](#実際の例で理解する)
8. [なぜこれが安全なのか](#なぜこれが安全なのか)

---

## 概要：ZKP検証とは

### 一言で言うと

**「データの中身を見せずに、データが正しいことを証明する技術」**

### 医療データの例で理解する

**従来の方法（データを公開）**:
```
データ提供者: 「患者Aは45歳、血圧120/80です」
データ購入者: 「確かに年齢も血圧も有効範囲内ですね」
→ 問題: 個人のデータが完全に漏れる
```

**ZKPを使った方法（データを秘匿）**:
```
データ提供者: 「患者データは全て有効範囲内です（証明を送信）」
データ購入者: 「証明を検証...確かに正しい！」
→ 実際の年齢や血圧は分からないまま、正当性だけが確認できる
```

---

## 検証に必要な3つのファイル

### 1. public_signals.json（公開信号）

**役割**: 検証に必要な公開パラメータ

**アナロジー**:
- 封筒の外側に書かれた「重要」「親展」などのラベル
- 中身（実際のデータ）を見なくても、外から確認できる情報

**内容例**:
```json
[
  "12345678901234567890",  // データ全体のハッシュ値（指紋）
  "1",                      // 年齢範囲チェックOK
  "1",                      // 血圧範囲チェックOK
  "1",                      // 血糖値範囲チェックOK
  "1"                       // コレステロール範囲チェックOK
]
```

### 2. proof.json（ZKP証明）

**役割**: 「public_signalsが正しい」という数学的証明

**アナロジー**:
- 署名や印鑑のようなもの
- 偽造不可能で、第三者が検証可能

**内容例（Groth16形式）**:
```json
{
  "pi_a": ["1234...", "5678...", "1"],
  "pi_b": [
    ["9012...", "3456..."],
    ["7890...", "1234..."],
    ["1", "0"]
  ],
  "pi_c": ["5678...", "9012...", "1"],
  "protocol": "groth16",
  "curve": "bn128"
}
```

### 3. verification_key.json（検証鍵）

**役割**: 証明を検証するための公開鍵

**アナロジー**:
- 印鑑証明書のようなもの
- 誰でも使えて、偽造を見抜ける

**重要性**:
- データ提供者が生成した正規のverification_keyでないと検証が通らない
- 改ざん検出の要

---

## public_signals.jsonの中身と意味

### 実際のファイルの構造

```json
[
  "15707963267948966192313883",   // インデックス0: データハッシュ
  "1",                             // インデックス1: 年齢範囲チェック結果
  "1",                             // インデックス2: 収縮期血圧範囲チェック結果
  "1",                             // インデックス3: 拡張期血圧範囲チェック結果
  "1",                             // インデックス4: 血糖値範囲チェック結果
  "1"                              // インデックス5: コレステロール範囲チェック結果
]
```

### 各要素の意味

#### インデックス0: データハッシュ

**何か**: 患者データ全体のハッシュ値（SHA256）

**用途**: データの完全性を保証
- データが1文字でも変わるとハッシュが変わる
- 改ざん検出の要

**例**:
```
元データ: 年齢=45, 血圧=120/80, 血糖=95
↓ ハッシュ化
ハッシュ: 15707963267948966192313883
```

もしデータが改ざんされると：
```
改ざん後: 年齢=46, 血圧=120/80, 血糖=95
↓ ハッシュ化
ハッシュ: 99999999999999999999999999  ← 全く違う値になる
```

#### インデックス1: 年齢範囲チェック

**検証内容**: `0 ≤ 年齢 ≤ 120`

**値の意味**:
- `1` = 範囲内（OK）
- `0` = 範囲外（NG）

**なぜ必要か**:
- 年齢が-10歳や200歳など、ありえない値でないことを保証
- データの品質を確認

#### インデックス2-5: 各健康指標の範囲チェック

同様に、各フィールドが有効範囲内かをチェック：

| インデックス | フィールド | 有効範囲 |
|------------|-----------|---------|
| 2 | 収縮期血圧 | 80-200 mmHg |
| 3 | 拡張期血圧 | 50-130 mmHg |
| 4 | 血糖値 | 50-300 mg/dL |
| 5 | コレステロール | 100-400 mg/dL |

**全て1なら**: データが医学的に妥当な範囲内であることを意味

---

## proof.jsonの中身と意味

### Groth16証明の構造

```json
{
  "pi_a": [
    "21888242871839275222246405745257275088696311157297823662689037894645226208583",
    "10857046999023057135944570762232829481370756359578518086990519993285655852781",
    "1"
  ],
  "pi_b": [
    [
      "10857046999023057135944570762232829481370756359578518086990519993285655852781",
      "21888242871839275222246405745257275088696311157297823662689037894645226208583"
    ],
    [
      "2345678901234567890123456789012345678901234567890123456789012345678901234567",
      "3456789012345678901234567890123456789012345678901234567890123456789012345678"
    ],
    ["1", "0"]
  ],
  "pi_c": [
    "4567890123456789012345678901234567890123456789012345678901234567890123456789",
    "5678901234567890123456789012345678901234567890123456789012345678901234567890",
    "1"
  ],
  "protocol": "groth16",
  "curve": "bn128"
}
```

### 各要素の意味

#### π_a, π_b, π_c（パイ・エー、パイ・ビー、パイ・シー）

**何か**: 楕円曲線上の点（数学的な座標）

**役割**:
- これらの3つの点が特定の関係を満たすことで、証明が正しいことを保証
- 偽造は数学的に不可能（計算量的に困難）

**アナロジー**:
- パズルのピースのようなもの
- 正しいピース（証明）だけが、正しく組み合わさる（検証成功）

#### protocol: "groth16"

**意味**: この証明はGroth16方式で生成されたことを示す

**Groth16の特徴**:
- 証明サイズが小さい（約1KB）
- 検証が高速（50ms以下）
- セキュリティが高い

#### curve: "bn128"

**意味**: BN128楕円曲線を使用

**楕円曲線とは**:
- 暗号学で使われる数学的構造
- ビットコインやイーサリアムでも使用されている信頼性の高い曲線

---

## verification_key.jsonの役割

### 検証鍵の構造

```json
{
  "protocol": "groth16",
  "curve": "bn128",
  "nPublic": 5,
  "vk_alpha_1": ["20491...", "1"],
  "vk_beta_2": [
    ["6375...", "4252..."],
    ["10505...", "11559..."],
    ["1", "0"]
  ],
  "vk_gamma_2": [...],
  "vk_delta_2": [...],
  "vk_alphabeta_12": [...],
  "IC": [
    ["5772...", "1"],
    ["1234...", "1"],
    // ... 6個の点（public signalsの数 + 1）
  ]
}
```

### 各要素の意味

#### nPublic: 5

**意味**: public_signalsの要素数

今回は5つ：年齢、収縮期血圧、拡張期血圧、血糖値、コレステロール

#### vk_alpha_1, vk_beta_2, vk_gamma_2, vk_delta_2

**役割**: 検証アルゴリズムで使用される楕円曲線上の点

**アナロジー**:
- 公開鍵のようなもの
- これらの値を使って、proof.jsonの正当性を数学的に検証

#### IC（Input Commitment）

**役割**: public_signalsと証明を結びつける

**重要性**:
- public_signalsの各値に対応する点
- 改ざんされたpublic_signalsでは検証が失敗する仕組み

---

## 検証の流れ：何が行われているか

### ステップバイステップ

#### ステップ1: ファイルの読み込み

```
データ購入者が以下をアップロード:
✓ proof.json
✓ public_signals.json
(verification_key.jsonはバックエンドに保存済み)
```

#### ステップ2: 楕円曲線ペアリングの計算

**数学的な検証式**（Groth16）:

$$
e(\pi_a, \pi_b) = e(vk_{\alpha}, vk_{\beta}) \cdot e(IC, vk_{\gamma}) \cdot e(\pi_c, vk_{\delta})
$$

**各記号の意味**:
- $e(P, Q)$: 楕円曲線ペアリング関数
- $\pi_a, \pi_b, \pi_c$: proof.jsonから
- $vk_{\alpha}, vk_{\beta}, vk_{\gamma}, vk_{\delta}$: verification_key.jsonから
- $IC$: public_signalsとverification_keyのICから計算

**アナロジー**:
- 錠前と鍵の関係
- 正しい鍵（正しいproof）だけが、錠前（検証式）を開ける

#### ステップ3: 検証結果の判定

**検証式が成り立つ** → **検証成功** ✅
```json
{
  "valid": true,
  "message": "Proof verification successful"
}
```

**検証式が成り立たない** → **検証失敗** ❌
```json
{
  "valid": false,
  "message": "Proof verification failed"
}
```

---

## 実際の例で理解する

### シナリオ: 患者Aのデータ検証

#### データ提供者側（暗号化パッケージ作成時）

**元データ**:
```json
{
  "patient_id": "P0001",
  "age": 45,
  "blood_pressure_systolic": 120,
  "blood_pressure_diastolic": 80,
  "blood_sugar": 95,
  "cholesterol": 180
}
```

**ステップ1: 範囲チェック**

```
年齢45 → 0 ≤ 45 ≤ 120 → OK (1)
血圧120 → 80 ≤ 120 ≤ 200 → OK (1)
血圧80 → 50 ≤ 80 ≤ 130 → OK (1)
血糖95 → 50 ≤ 95 ≤ 300 → OK (1)
コレステロール180 → 100 ≤ 180 ≤ 400 → OK (1)
```

**ステップ2: ハッシュ計算**

```
データ全体をハッシュ化:
Hash("P0001,45,120,80,95,180") = 15707963267948966192313883
```

**ステップ3: public_signals生成**

```json
[
  "15707963267948966192313883",  // データハッシュ
  "1",  // 年齢OK
  "1",  // 血圧（収縮期）OK
  "1",  // 血圧（拡張期）OK
  "1",  // 血糖OK
  "1"   // コレステロールOK
]
```

**ステップ4: ZKP証明生成**

```
Circom回路を実行:
入力: 元データ（秘密）
出力: proof.json（π_a, π_b, π_c）

この証明により、以下が保証される:
✓ public_signalsは元データから正しく計算された
✓ 元データは範囲チェックを全て満たす
✓ ハッシュ値は改ざんされていない
```

#### データ購入者側（検証時）

**受け取るもの**:
- proof.json
- public_signals.json
- verification_key.json

**検証プロセス**:

```
1. public_signalsを確認:
   → 全て"1" = 全フィールドが有効範囲内

2. proof.jsonとverification_key.jsonで検証:
   → ペアリング計算を実行
   → 検証式が成り立つ = 証明が正しい

3. 結論:
   ✓ データは改ざんされていない（ハッシュ一致）
   ✓ データは有効範囲内（全チェックOK）
   ✓ データ提供者は正規（verification_key一致）
```

**重要**: この全プロセスで、実際の年齢45や血圧120/80という値は一切知られない！

---

## なぜこれが安全なのか

### 1. 改ざん検出

**ケース1: public_signalsを改ざん**

```
正規: ["15707963267948966192313883", "1", "1", "1", "1", "1"]
改ざん: ["15707963267948966192313883", "0", "1", "1", "1", "1"]
         ↑ 年齢チェックを"0"に変更

検証結果: ❌ 失敗
理由: proof.jsonは元のpublic_signalsに対する証明なので、
      改ざん後のpublic_signalsでは検証式が成り立たない
```

**ケース2: 元データを改ざん**

```
正規データ: 年齢45
改ざん: 年齢46に変更

結果:
- ハッシュ値が変わる
- 新しいハッシュ値に対する証明がない
- 検証失敗 ❌
```

**ケース3: proof.jsonを偽造**

```
偽の証明を生成しようとする

結果:
- 楕円曲線離散対数問題を解く必要がある
- 現在の計算機では事実上不可能（数十億年かかる）
- 偽造不可能 ❌
```

### 2. ゼロ知識性

**証明から分かること**:
- ✅ データは有効範囲内
- ✅ データは改ざんされていない
- ✅ データ提供者は正規

**証明から分からないこと**:
- ❌ 実際の年齢
- ❌ 実際の血圧
- ❌ 実際の血糖値
- ❌ その他の個人情報

**なぜ分からないか**:
- proof.jsonは数学的な証明（楕円曲線上の点）
- 元データから逆算することは計算量的に不可能
- ハッシュ値から元データを復元することも不可能（一方向性）

### 3. 検証の確実性

**確率論的な保証**:

```
証明が正しい場合:
  検証成功率 = 100%（完全性）

証明が偽の場合:
  検証成功率 < 0.0000...001%（健全性）
  （事実上0%）
```

**なぜ確実か**:
- Groth16はSNARK（Succinct Non-interactive ARgument of Knowledge）
- 数学的に証明された安全性
- ビットコインやイーサリアムでも使用される信頼性

---

## まとめ

### 検証の本質

**3つのファイルの役割**:

1. **public_signals.json**:
   - 検証したい事実（範囲内、ハッシュ一致）を公開
   - データの中身は含まない

2. **proof.json**:
   - 「public_signalsが正しい」という数学的証明
   - 偽造不可能、逆算不可能

3. **verification_key.json**:
   - 証明を検証するための公開鍵
   - 誰でも検証可能

### なぜZKPが必要か

**従来の方法の問題点**:
```
データを公開 → プライバシー侵害
データを隠す → 信頼性が分からない
```

**ZKPによる解決**:
```
データを隠したまま → プライバシー保護 ✅
正当性を証明 → 信頼性確保 ✅
```

### 実社会での意義

**医療データマーケットプレイス**:
- データ提供者: 患者のプライバシーを守りながらデータ販売
- データ購入者: 高品質なデータであることを確認して購入
- 患者: 自分のデータが保護されたまま医療研究に貢献

**Win-Win-Win** の関係が成立！

---

## 付録: よくある質問

### Q1: proof.jsonは誰でも検証できるのか？

**A**: はい、verification_key.jsonがあれば誰でも検証できます。

- これがZKPの「公開検証可能性」です
- 第三者による監査が可能
- 信頼性が高まる

### Q2: verification_keyが盗まれたら危険では？

**A**: いいえ、verification_keyは公開鍵なので問題ありません。

- 検証にしか使えない
- 新しい証明を生成することはできない
- データを復号することもできない

### Q3: ハッシュ値から元データは分からないのか？

**A**: 分かりません。ハッシュ関数は一方向性です。

```
データ → ハッシュ化 → ハッシュ値（簡単）
ハッシュ値 → 逆算 → データ（事実上不可能）
```

総当たり攻撃も、医療データの組み合わせは天文学的な数なので現実的ではありません。

### Q4: public_signalsの値が全て"1"なら、それだけで十分では？

**A**: いいえ、proof.jsonがないと信頼できません。

- public_signalsだけなら誰でも"1"を並べられる
- proof.jsonがあって初めて「本当に範囲内だ」と保証される
- これがZKPの本質

### Q5: 検証に何秒かかるのか？

**A**: 非常に高速です。

- 証明生成: 3-5秒
- 証明検証: 50ms以下
- 証明サイズ: 約1KB

これがzkSNARKの「Succinct（簡潔）」の意味です。

---

## 参考資料

- [Circom Documentation](https://docs.circom.io/)
- [snarkjs](https://github.com/iden3/snarkjs)
- [Groth16論文](https://eprint.iacr.org/2016/260.pdf)
- [Zero-Knowledge Proofs: An Illustrated Primer](https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/)
